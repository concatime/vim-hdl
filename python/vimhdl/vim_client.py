# This file is part of vim-hdl.
#
# vim-hdl is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# vim-hdl is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with vim-hdl.  If not, see <http://www.gnu.org/licenses/>.
"Wrapper for vim-hdl usage within Vim's Python interpreter"

import logging
import os.path as p
import threading
from multiprocessing import Queue

import vim # pylint: disable=import-error
import vimhdl.vim_helpers as vim_helpers

from hdlcc import ProjectBuilder

_logger = logging.getLogger(__name__)
_vim_hdl_clients = {}          # pylint: disable=invalid-name

class HDLCodeCheckerClient(ProjectBuilder):
    '''Wrapper around hdlcc.ProjectBuilder class to make the interface between
    Vim and vim-hdl'''

    _ui_msg_queue = Queue()
    _vim_thread = threading.currentThread()

    def __repr__(self):
        return "%s.HDLCodeCheckerClient('%s')" % (__name__, self.project_file)

    def _isMainThread(self):
        '''Returns wether we're running on the same thread used to create
        the project builder object. This should avoid Vim crashing when
        posting messages from another thread.'''
        return threading.currentThread().ident == self._vim_thread.ident

    def _postOrSchedule(self, severity, message):
        '''If the caller is not in our thread, we'll schedule to post
        the message later'''
        if self._isMainThread():
            if severity == 'info':
                vim_helpers.postVimInfo(message)
            elif severity == 'warning':
                vim_helpers.postVimWarning(message)
            elif severity == 'error':
                vim_helpers.postVimError(message)
            else:
                vim_helpers.postVimError(
                    "Unknown severity '%s' for message '%s'" %
                    (severity, message))
        else:
            self._ui_msg_queue.put({'type' : severity, 'text' : message})

    def _handleUiInfo(self, message):
        self._postOrSchedule('info', message)

    def _handleUiWarning(self, message):
        self._postOrSchedule('warning', message)

    def _handleUiError(self, message):
        self._postOrSchedule('error', message)

    def postQueuedMessages(self):
        '''Because Vim doesn't allows commands from non-GUI threads,
        we enqueue messages generated by background threads and post
        them whenever Vim is ready'''
        while not self._ui_msg_queue.empty():
            msg = self._ui_msg_queue.get()
            if msg['type'] == 'info':
                vim_helpers.postVimInfo(msg['text'])
            elif msg['type'] == 'warning':
                vim_helpers.postVimWarning(msg['text'])
            elif msg['type'] == 'error':
                vim_helpers.postVimError(msg['text'])


def _getProjectFile():
    '''Searches for a valid hdlcc configuration file in buffer vars
    (i.e., inside b:) then in global vars (i.e., inside g:)'''
    conf_file = None
    if 'vimhdl_conf_file' in vim_helpers.getBufferVars():
        conf_file = vim_helpers.getBufferVars('vimhdl_conf_file')
        if not p.exists(conf_file):
            _logger.warning("Buffer config file '%s' is set but not " \
                    "readable", conf_file)
            conf_file = None

    if conf_file is None:
        if 'vimhdl_conf_file' in vim_helpers.getVimGlobals():
            conf_file = vim_helpers.getVimGlobals('vimhdl_conf_file')
            if not p.exists(conf_file):
                _logger.warning("Global config file '%s' is set but not " \
                        "readable", conf_file)
                conf_file = None

    if conf_file is None:
        _logger.warning("Couldn't find a valid config file")
        return

    conf_file_full_path = p.abspath(p.expanduser(conf_file))

    if p.exists(conf_file_full_path):
        return conf_file_full_path
    else:
        _logger.warning("Config file '%s' doesn't exists", conf_file_full_path)

def _getClient():
    '''Returns the HDLCodeCheckerClient or creates it if it doesn't
    exists. The key for checking if it exists is the configuration file'''

    project_file = _getProjectFile()

    if project_file not in _vim_hdl_clients.keys():
        _vim_hdl_clients[project_file] = HDLCodeCheckerClient(project_file)

    return _vim_hdl_clients[project_file]

def vimWrap(func):
    '''Gets an HDLCodeCheckerClient object to call 'func' with it as the
    first parameter.'''
    def _vimWrap(*args, **kwargs): # pylint: disable=missing-docstring
        buf = kwargs.pop('buf', vim.current.buffer)
        client = _getClient()
        if client is None:
            _logger.debug("%s(%s, %s) => None [skipped]", func.func_name,
                          args, kwargs)
            return
        else:
            _logger.debug("%s(%s, %s, %s, %s)", func.func_name,
                          client, buf, args, kwargs)

        result = func(client, buf, *args, **kwargs)
        return result
    return _vimWrap

def _sortBuildMessages(records):
    "Sorts the build messages using Vim's terminology"
    for record in records:
        for key in ('lnum', 'nr', 'col'):
            try:
                record[key] = int(record[key])
            except ValueError:
                pass
    records.sort(key=lambda x: (x['type'], x['lnum'], x['col'], x['nr']))
    return records


#############################################
# Functions that are actually called by Vim #
#############################################

# More info on :help getqflist()
@vimWrap
def getMessages(client, vim_buffer):
    '''Returns a list (vim.List) of messages (vim.Dictionary) to
    populate the quickfix list'''
    client.postQueuedMessages()

    messages = []
    for message in client.getMessagesByPath(vim_buffer.name):
        vim_fmt_dict = {
            'lnum'     : message['line_number'] or '-1',
            'bufnr'    : vim_buffer.number,
            'filename' : message['filename'] or vim_buffer.name,
            'valid'    : '1',
            'text'     : message['error_message'] or '<none>',
            'nr'       : message['error_number'] or '0',
            'type'     : message['error_type'] or 'E',
            'col'      : message['column'] or '0'
        }
        try:
            vim_fmt_dict['subtype'] = message['error_subtype']
        except KeyError:
            pass

        _logger.info(vim_fmt_dict)

        messages.append(vim_helpers.dict(vim_fmt_dict))

    client.postQueuedMessages()
    return vim_helpers.list(_sortBuildMessages(messages))

# pylint: disable=missing-docstring,unused-argument
@vimWrap
def postQueuedMessages(client, vim_buffer):
    client.postQueuedMessages()

# pylint: disable=missing-docstring,unused-argument
